<!-- doc/src/sgml/anyarray.sgml -->

<sect1 id="anyarray" xreflabel="anyarray">
 <title>anyarray</title>

 <indexterm zone="anyarray">
  <primary>anyarray</primary>
 </indexterm>

 <para>
  The <filename>anyarray</> module provides a number of useful functions
  and operators for manipulating null-free arrays.
  There is also support for indexed searches using some of the operators.
  The <filename>anyarray</> module is a generalization and replacement
  of <filename>intarray</> module.
 </para>

 <para>
  All of these operations will throw an error if a supplied array contains any
  NULL elements.
 </para>

 <para>
  Many of these operations are only sensible for one-dimensional arrays.
  Although they will accept input arrays of more dimensions, the data is
  treated as though it were a linear array in storage order.
 </para>

 <sect2>
  <title><filename>anyarray</> Functions and Operators</title>

  <para>
   The functions provided by the <filename>anyarray</filename> module
   are shown in <xref linkend="anyarray-func-table">, the operators
   in <xref linkend="anyarray-op-table">.
  </para>

  <table id="anyarray-func-table">
   <title><filename>anyarray</> Functions</title>

   <tgroup cols="5">
    <thead>
     <row>
      <entry>Function</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
      <entry>Example</entry>
      <entry>Result</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><function>icount(anyarray)</function><indexterm><primary>icount</primary></indexterm></entry>
      <entry><type>int</type></entry>
      <entry>number of elements in array</entry>
      <entry><literal>icount('{1,2,3}'::int[])</literal></entry>
      <entry><literal>3</literal></entry>
     </row>

     <row>
      <entry><function>sort(anyarray, text dir)</function><indexterm><primary>sort</primary></indexterm></entry>
      <entry><type>anyarray</type></entry>
      <entry>sort array &mdash; <parameter>dir</> must be <literal>asc</> or <literal>desc</></entry>
      <entry><literal>sort('{1,2,3}'::int[], 'desc')</literal></entry>
      <entry><literal>{3,2,1}</literal></entry>
     </row>

     <row>
      <entry><function>sort(anyarray)</function></entry>
      <entry><type>anyarray</type></entry>
      <entry>sort in ascending order</entry>
      <entry><literal>sort(array[11,77,44])</literal></entry>
      <entry><literal>{11,44,77}</literal></entry>
     </row>

     <row>
      <entry><function>sort_asc(anyarray)</function><indexterm><primary>sort_asc</primary></indexterm></entry>
      <entry><type>anyarray</type></entry>
      <entry>sort in ascending order</entry>
      <entry><literal></literal></entry>
      <entry><literal></literal></entry>
     </row>

     <row>
      <entry><function>sort_desc(anyarray)</function><indexterm><primary>sort_desc</primary></indexterm></entry>
      <entry><type>anyarray</type></entry>
      <entry>sort in descending order</entry>
      <entry><literal></literal></entry>
      <entry><literal></literal></entry>
     </row>

     <row>
      <entry><function>uniq(anyarray)</function><indexterm><primary>uniq</primary></indexterm></entry>
      <entry><type>anyarray</type></entry>
      <entry>remove adjacent duplicates</entry>
      <entry><literal>uniq(sort('{1,2,3,2,1}'::int[]))</literal></entry>
      <entry><literal>{1,2,3}</literal></entry>
     </row>

     <row>
      <entry><function>uniq_d(anyarray)</function><indexterm><primary>uniq_d</primary></indexterm></entry>
      <entry><type>anyarray</type></entry>
      <entry>leave only duplicates (similar to <command>uniq -d</command>)</entry>
      <entry><literal>uniq_d(sort('{1,2,3,2,1}'::int[]))</literal></entry>
      <entry><literal>{1,2}</literal></entry>
     </row>

     <row>
      <entry><function>idx(anyarray, anyelement item)</function><indexterm><primary>idx</primary></indexterm></entry>
      <entry><type>int</type></entry>
      <entry>index of first element matching <parameter>item</> (0 if none)</entry>
      <entry><literal>idx(array[11,22,33,22,11], 22)</literal></entry>
      <entry><literal>2</literal></entry>
     </row>

     <row>
      <entry><function>subarray(anyarray, int start, int len)</function><indexterm><primary>subarray</primary></indexterm></entry>
      <entry><type>anyarray</type></entry>
      <entry>portion of array starting at position <parameter>start</>, <parameter>len</> elements</entry>
      <entry><literal>subarray('{1,2,3,2,1}'::int[], 2, 3)</literal></entry>
      <entry><literal>{2,3,2}</literal></entry>
     </row>

     <row>
      <entry><function>subarray(anyarray, int start)</function></entry>
      <entry><type>anyarray</type></entry>
      <entry>portion of array starting at position <parameter>start</></entry>
      <entry><literal>subarray('{1,2,3,2,1}'::int[], 2)</literal></entry>
      <entry><literal>{2,3,2,1}</literal></entry>
     </row>

     <row>
      <entry><function>anyset(anyelement)</function><indexterm><primary>anyset</primary></indexterm></entry>
      <entry><type>anyarray</type></entry>
      <entry>make single-element array</entry>
      <entry><literal>anyset(42)</literal></entry>
      <entry><literal>{42}</literal></entry>
     </row>

     <row>
      <entry><function>similarity(anyarray, anyarray)</function><indexterm><primary>similarity</primary></indexterm></entry>
      <entry><type>float4</type></entry>
      <entry>make single-element array</entry>
      <entry><literal>similarity('{3,2}'::text[], '{3,2,1}')</literal></entry>
      <entry><literal>0.816497</literal></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <table id="anyarray-op-table">
   <title><filename>anyarray</> Operators</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Operator</entry>
      <entry>Returns</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal># anyarray</literal></entry>
      <entry><type>int</type></entry>
      <entry>number of elements in array</entry>
     </row>
     <row>
      <entry><literal>anyarray + anyelement</literal></entry>
      <entry><type>anyarray</type></entry>
      <entry>push element onto array (add it to end of array)</entry>
     </row>
     <row>
      <entry><literal>anyarray + anyarray  </literal></entry>
      <entry><type>anyarray</type></entry>
      <entry>array concatenation (right array added to the end of left one)</entry>
     </row>
     <row>
      <entry><literal>anyarray - anyelement</literal></entry>
      <entry><type>anyarray</type></entry>
      <entry>remove entries matching right argument from array</entry>
     </row>
     <row>
      <entry><literal>anyarray - anyarray</literal></entry>
      <entry><type>anyarray</type></entry>
      <entry>remove elements of right array from left</entry>
     </row>
     <row>
      <entry><literal>anyarray | anyelement</literal></entry>
      <entry><type>anyarray</type></entry>
      <entry>union of arguments</entry>
     </row>
     <row>
      <entry><literal>anyarray | anyarray</literal></entry>
      <entry><type>anyarray</type></entry>
      <entry>union of arrays</entry>
     </row>
     <row>
      <entry><literal>anyarray &amp; anyarray</literal></entry>
      <entry><type>anyarray</type></entry>
      <entry>intersection of arrays</entry>
     </row>
     <row>
      <entry><literal>anyarray % anyarray  </literal></entry>
      <entry><type>bool</type></entry>
      <entry>returns true if arrays are similar</entry>
     </row>
     <row>
      <entry><literal>int[] @@ query_int</literal></entry>
      <entry><type>boolean</type></entry>
      <entry><literal>true</> if array satisfies query (see below)</entry>
     </row>
     <row>
      <entry><literal>query_int ~~ int[]</literal></entry>
      <entry><type>boolean</type></entry>
      <entry><literal>true</> if array satisfies query (commutator of <literal>@@</>)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   The <literal>@@</> and <literal>~~</> operators test whether an array
   satisfies a <firstterm>query</>, which is expressed as a value of a
   specialized data type <type>query_int</>.  A <firstterm>query</>
   consists of integer values that are checked against the elements of
   the array, possibly combined using the operators <literal>&amp;</>
   (AND), <literal>|</> (OR), and <literal>!</> (NOT).  Parentheses
   can be used as needed.  For example,
   the query <literal>1&amp;(2|3)</> matches arrays that contain 1
   and also contain either 2 or 3.
  </para>
 </sect2>

 <sect2>
  <title>GUC configuration variables</title>

  <variablelist>
   <varlistentry>
    <term>
     <varname>anyarray.similarity_threshold</> (<type>double</type>)
     <indexterm>
      <primary><varname>anyarray.similarity_threshold</> configuration parameter</primary>
     </indexterm>
    </term>
    <listitem>
     <para>
	  Lower threshold of array's similarity, array's with similarity 
	  lower than threshold are not similar by % operation. Default: 0.6. 
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <varname>anyarray.similarity_type</> (<type>enum</type>)
     <indexterm>
      <primary><varname>anyarray.similarity_type</> configuration parameter</primary>
     </indexterm>
    </term>
    <listitem>
     <para>
	  Type of similarity formula: <literal>cosine</>(default), <literal>jaccard</>, <literal>overlap</>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

 </sect2>

 <sect2>
  <title>Index Support</title>

  <para>
   <filename>anyarray</> provides index support for the
   <literal>&amp;&amp;</>, <literal>@&gt;</>, <literal>&lt;@</>,
   and <literal>@@</> operators, as well as regular array equality.
  </para>

  <para>
   Two GiST index operator classes are provided:
   <literal>gist__int_ops</> (used by default) is suitable for
   small- to medium-size data sets, while
   <literal>gist__intbig_ops</> uses a larger signature and is more
   suitable for indexing large data sets (i.e., columns containing
   a large number of distinct array values).
   The implementation uses an RD-tree data structure with
   built-in lossy compression.
  </para>

  <para>
   There is also a non-default GIN operator class
   <literal>gin__int_ops</> supporting the same operators.
  </para>

  <para>
   The choice between GiST and GIN indexing depends on the relative
   performance characteristics of GiST and GIN, which are discussed elsewhere.
   As a rule of thumb, a GIN index is faster to search than a GiST index, but
   slower to build or update; so GIN is better suited for static data and GiST
   for often-updated data.
  </para>
 </sect2>

 <sect2>
  <title>Example</title>

<programlisting>
-- a message can be in one or more <quote>sections</>
CREATE TABLE message (mid INT PRIMARY KEY, sections INT[], ...);

-- create specialized index
CREATE INDEX message_rdtree_idx ON message USING GIST (sections gist__int_ops);

-- select messages in section 1 OR 2 - OVERLAP operator
SELECT message.mid FROM message WHERE message.sections &amp;&amp; '{1,2}';

-- select messages in sections 1 AND 2 - CONTAINS operator
SELECT message.mid FROM message WHERE message.sections @&gt; '{1,2}';

-- the same, using QUERY operator
SELECT message.mid FROM message WHERE message.sections @@ '1&amp;2'::query_int;
</programlisting>
 </sect2>

 <sect2>
  <title>Authors</title>

  <para>
   Teodor Sigaev (<email>teodor@sigaev.ru</email>) 
  </para>
 </sect2>

</sect1>
